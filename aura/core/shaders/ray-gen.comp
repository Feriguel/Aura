// ========================================================================== //
// File : ray_gen.comp
//
// Author : Miguel Ângelo Crespo Ferreira
// ========================================================================== //
#version 460
// Workspace settings.
layout(local_size_x = 16, local_size_y = 16, local_size_z = 1) in;
// Structures.
struct Ray {
	vec3 origin;
	vec3 direction;
	vec3 albedo;
	uint missed;
};
struct Hit {
	vec3 point;
	float time;
	vec3 normal;
	uint m_idx;
	uint inside;
};
// Layout bindings.
layout(std140, set = 0, binding = 0) uniform Settings {
	float t_min;
	float t_max;
	uint n_bounces;
	uint n_samples;
	uint n_primitives;
	uint width;
	uint height;
};
layout(std140, set = 1, binding = 0) uniform Launcher {
	vec3 origin;
	float lens_radius;
	vec3 corner;
	vec3 horizontal;
	vec3 vertical;
	vec3 u;
	vec3 v;
	vec3 w;
};
layout(std140, set = 2, binding = 0) buffer restrict writeonly Rays {
	Ray[] rays;
};
layout(std140, set = 2, binding = 1) buffer restrict writeonly Hits {
	Hit[] hits;
};
layout(std140, set = 2, binding = 2) buffer restrict writeonly Pixels {
	vec4[] pixels;
};
layout(push_constant) uniform Random { 
	vec2 r;
};
// Input: It uses texture coords as the random number seed.
// Output: Random number: [0,1), that is between 0.0 and 0.999999... inclusive.
// Author: Michael Pohoreski
// Copyright: Copyleft 2012 :-)
// NOTE: This has been upgraded to version 3 !!
float random( vec2 p )
{
	// We need irrationals for pseudo randomness.
	// Most (all?) known transcendental numbers will (generally) work.
	const vec2 r = vec2(
		23.1406926327792690,	// e^pi (Gelfond's constant)
		2.6651441426902251		// 2^sqrt(2) (Gelfond–Schneider constant)
	);
	return fract( cos( mod( 123456789., 1e-7 + 256. * dot(p,r) ) ) );  
}
// Generates a ray for each workspace position and initialises the hit structures.
// The work space should be the output image dimensions.
void main()
{
	if(gl_GlobalInvocationID.s > width || gl_GlobalInvocationID.t > height) { return; }
	const uint idx = gl_GlobalInvocationID.s + gl_GlobalInvocationID.t * width;
	// Calculate target point (pixel coordinates).
	const float s = float(gl_GlobalInvocationID.s) / width;
	const float t = float(gl_GlobalInvocationID.t) / height;
	// Randomize origin within the lens and set albedo.
	const vec3 o = origin + u * lens_radius * r.s + v * lens_radius * r.t;
	rays[idx].origin = o;
	rays[idx].albedo = vec3(1.0, 1.0, 1.0);
	// Calculate direction and length.
	const vec3 d = corner + s * horizontal - t * vertical - o;
	const float l = length(d);
	// Set bounces left and direction if length is not 0.
	if (l == 0)
	{
		rays[idx].missed = 1;
		hits[idx].time = 0.0;
	}
	else
	{
		rays[idx].missed = 0;
		rays[idx].direction = d / l;
		hits[idx].time = 0.0;
	}
}